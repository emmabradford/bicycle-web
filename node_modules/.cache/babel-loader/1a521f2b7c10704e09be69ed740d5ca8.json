{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/appointmentSettingsGenerator.js)\r\n * Version: 20.2.7\r\n * Build date: Thu Apr 22 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nexports.AppointmentSettingsGeneratorVirtualStrategy = exports.AppointmentSettingsGeneratorBaseStrategy = exports.AppointmentSettingsGenerator = void 0;\n\nvar _date = _interopRequireDefault(require(\"../../core/utils/date\"));\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _recurrence = require(\"./recurrence\");\n\nvar _utilsTimeZone = _interopRequireDefault(require(\"./utils.timeZone.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (\"undefined\" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter[\"@@iterator\"]) {\n    return Array.from(iter);\n  }\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    return _arrayLikeToArray(arr);\n  }\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) {\n    return;\n  }\n\n  if (\"string\" === typeof o) {\n    return _arrayLikeToArray(o, minLen);\n  }\n\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n\n  if (\"Object\" === n && o.constructor) {\n    n = o.constructor.name;\n  }\n\n  if (\"Map\" === n || \"Set\" === n) {\n    return Array.from(o);\n  }\n\n  if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\n    return _arrayLikeToArray(o, minLen);\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (null == len || len > arr.length) {\n    len = arr.length;\n  }\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (\"undefined\" !== typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (null == _i) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else {\n      if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar toMs = _date.default.dateToMilliseconds;\n\nvar AppointmentSettingsGenerator = function () {\n  function AppointmentSettingsGenerator(scheduler) {\n    this.scheduler = scheduler;\n    this.settingsStrategy = this.scheduler.isVirtualScrolling() ? new AppointmentSettingsGeneratorVirtualStrategy(this.scheduler) : new AppointmentSettingsGeneratorBaseStrategy(this.scheduler);\n  }\n\n  var _proto = AppointmentSettingsGenerator.prototype;\n\n  _proto.create = function (rawAppointment) {\n    return this.settingsStrategy.create(rawAppointment);\n  };\n\n  return AppointmentSettingsGenerator;\n}();\n\nexports.AppointmentSettingsGenerator = AppointmentSettingsGenerator;\n\nvar AppointmentSettingsGeneratorBaseStrategy = function () {\n  function AppointmentSettingsGeneratorBaseStrategy(scheduler) {\n    this.scheduler = scheduler;\n  }\n\n  var _proto2 = AppointmentSettingsGeneratorBaseStrategy.prototype;\n\n  _proto2.create = function (rawAppointment) {\n    var scheduler = this.scheduler;\n    var appointment = scheduler.createAppointmentAdapter(rawAppointment);\n\n    var itemResources = scheduler._resourcesManager.getResourcesFromItem(rawAppointment);\n\n    var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n    var appointmentList = this._createAppointments(appointment, itemResources);\n\n    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointment);\n\n    if (this._canProcessNotNativeTimezoneDates(appointment)) {\n      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointment);\n    }\n\n    var gridAppointmentList = this._createGridAppointmentList(appointmentList, appointment);\n\n    gridAppointmentList = this._cropAppointmentsByStartDayHour(gridAppointmentList, rawAppointment, isAllDay);\n    gridAppointmentList = this._getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment);\n\n    var appointmentInfos = this._createAppointmentInfos(gridAppointmentList, itemResources, isAllDay, appointment.isRecurrent);\n\n    return appointmentInfos;\n  };\n\n  _proto2._getProcessedByAppointmentTimeZone = function (appointmentList, appointment) {\n    var _this = this;\n\n    var hasAppointmentTimeZone = !(0, _type.isEmptyObject)(appointment.startDateTimeZone) || !(0, _type.isEmptyObject)(appointment.endDateTimeZone);\n\n    if (appointmentList.length > 1 && hasAppointmentTimeZone) {\n      var appointmentOffsets = {\n        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n      };\n      appointmentList.forEach(function (a) {\n        var sourceOffsets = {\n          startDate: _this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n          endDate: _this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone)\n        };\n        var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets.startDate.appointment;\n        var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets.endDate.appointment;\n\n        if (0 !== startDateOffsetDiff) {\n          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n        }\n\n        if (0 !== endDateOffsetDiff) {\n          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n        }\n      });\n    }\n\n    return appointmentList;\n  };\n\n  _proto2._isAllDayAppointment = function (rawAppointment) {\n    return this.scheduler.appointmentTakesAllDay(rawAppointment) && this.workspace.supportAllDayRow();\n  };\n\n  _proto2._createAppointments = function (appointment, resources) {\n    var appointments = this._createRecurrenceAppointments(appointment, resources);\n\n    if (!appointment.isRecurrent && 0 === appointments.length) {\n      appointments.push({\n        startDate: appointment.startDate,\n        endDate: appointment.endDate\n      });\n    }\n\n    appointments = appointments.map(function (item) {\n      var _item$endDate;\n\n      var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n      if (item.startDate.getTime() === resultEndTime) {\n        item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n      }\n\n      return _objectSpread(_objectSpread({}, item), {}, {\n        exceptionDate: new Date(item.startDate)\n      });\n    });\n    return appointments;\n  };\n\n  _proto2._canProcessNotNativeTimezoneDates = function (appointment) {\n    var timeZoneName = this.scheduler.option(\"timeZone\");\n    var isTimeZoneSet = !(0, _type.isEmptyObject)(timeZoneName);\n\n    if (!isTimeZoneSet) {\n      return false;\n    }\n\n    if (!appointment.isRecurrent) {\n      return false;\n    }\n\n    return !_utilsTimeZone.default.isEqualLocalTimeZone(timeZoneName, appointment.startDate);\n  };\n\n  _proto2._getProcessedNotNativeDateIfCrossDST = function (date, offset) {\n    if (offset < 0) {\n      var newDate = new Date(date);\n      var newDateMinusOneHour = new Date(newDate);\n      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n      var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n      var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n      if (newDateOffset !== newDateMinusOneHourOffset) {\n        return 0;\n      }\n    }\n\n    return offset;\n  };\n\n  _proto2._getProcessedNotNativeTimezoneDates = function (appointmentList, appointment) {\n    var _this2 = this;\n\n    var startDateRange = appointment.startDate;\n    var endDateRange = appointmentList[appointmentList.length - 1].endDate;\n    var startDateRangeOffset = this.timeZoneCalculator.getOffsets(startDateRange).common;\n    var endDateRangeOffset = this.timeZoneCalculator.getOffsets(endDateRange).common;\n    var isChangeOffsetInRange = startDateRangeOffset !== endDateRangeOffset;\n\n    if (isChangeOffsetInRange) {\n      return appointmentList.map(function (a) {\n        var diffStartDateOffset = _this2.timeZoneCalculator.getOffsets(appointment.startDate).common - _this2.timeZoneCalculator.getOffsets(a.startDate).common;\n\n        var diffEndDateOffset = _this2.timeZoneCalculator.getOffsets(appointment.endDate).common - _this2.timeZoneCalculator.getOffsets(a.endDate).common;\n\n        diffStartDateOffset = _this2._getProcessedNotNativeDateIfCrossDST(a.startDate, diffStartDateOffset);\n        diffEndDateOffset = _this2._getProcessedNotNativeDateIfCrossDST(a.endDate, diffEndDateOffset);\n        var newStartDate = new Date(a.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n        var newEndDate = new Date(a.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n\n        var testNewStartDate = _this2.timeZoneCalculator.createDate(newStartDate, {\n          path: \"toGrid\"\n        });\n\n        var testNewEndDate = _this2.timeZoneCalculator.createDate(newEndDate, {\n          path: \"toGrid\"\n        });\n\n        if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n          newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n        }\n\n        return {\n          startDate: newStartDate,\n          endDate: newEndDate,\n          exceptionDate: new Date(newStartDate)\n        };\n      });\n    }\n\n    return appointmentList;\n  };\n\n  _proto2._getProcessedLongAppointmentsIfRequired = function (gridAppointmentList, appointment) {\n    var _this3 = this;\n\n    var rawAppointment = appointment.source();\n    var allDay = this.scheduler.appointmentTakesAllDay(rawAppointment);\n    var dateRange = this.workspace.getDateRange();\n    var renderingStrategy = this.scheduler.getLayoutManager().getRenderingStrategyInstance();\n\n    if (renderingStrategy.needSeparateAppointment(allDay)) {\n      var longStartDateParts = [];\n      var resultDates = [];\n      gridAppointmentList.forEach(function (gridAppointment) {\n        var maxDate = new Date(dateRange[1]);\n        var endDateOfPart = renderingStrategy.normalizeEndDateByViewEnd(rawAppointment, gridAppointment.endDate);\n        longStartDateParts = _date.default.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n          milliseconds: _this3.scheduler.getWorkSpace().getIntervalDuration(allDay)\n        });\n        var list = longStartDateParts.filter(function (startDatePart) {\n          return new Date(startDatePart) < maxDate;\n        }).map(function (date) {\n          return {\n            startDate: date,\n            endDate: new Date(new Date(date).setMilliseconds(appointment.duration)),\n            source: gridAppointment.source\n          };\n        });\n        resultDates = resultDates.concat(list);\n      });\n      gridAppointmentList = resultDates;\n    }\n\n    return gridAppointmentList;\n  };\n\n  _proto2._createGridAppointmentList = function (appointmentList, appointment) {\n    var _this4 = this;\n\n    return appointmentList.map(function (source) {\n      var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n      if (0 !== offsetDifference && _this4._canProcessNotNativeTimezoneDates(appointment)) {\n        source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.exceptionDate = new Date(source.startDate);\n      }\n\n      var startDate = _this4.timeZoneCalculator.createDate(source.startDate, {\n        path: \"toGrid\"\n      });\n\n      var endDate = _this4.timeZoneCalculator.createDate(source.endDate, {\n        path: \"toGrid\"\n      });\n\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        source: source\n      };\n    });\n  };\n\n  _proto2._createExtremeRecurrenceDates = function (rawAppointment) {\n    var dateRange = this.workspace.getDateRange();\n    var startViewDate = this.scheduler.appointmentTakesAllDay(rawAppointment) ? _date.default.trimTime(dateRange[0]) : dateRange[0];\n    var endViewDate = dateRange[1];\n    var commonTimeZone = this.scheduler.option(\"timeZone\");\n\n    if (commonTimeZone) {\n      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n        path: \"fromGrid\"\n      });\n      endViewDate = this.timeZoneCalculator.createDate(endViewDate, {\n        path: \"fromGrid\"\n      });\n\n      var daylightOffset = _utilsTimeZone.default.getDaylightOffsetInMs(startViewDate, endViewDate);\n\n      if (daylightOffset) {\n        endViewDate = new Date(endViewDate.getTime() + daylightOffset);\n      }\n    }\n\n    return [startViewDate, endViewDate];\n  };\n\n  _proto2._createRecurrenceOptions = function (appointment, groupIndex) {\n    var _this5 = this;\n\n    var _this$_createExtremeR = this._createExtremeRecurrenceDates(appointment.source(), groupIndex),\n        _this$_createExtremeR2 = _slicedToArray(_this$_createExtremeR, 2),\n        minRecurrenceDate = _this$_createExtremeR2[0],\n        maxRecurrenceDate = _this$_createExtremeR2[1];\n\n    return {\n      rule: appointment.recurrenceRule,\n      exception: appointment.recurrenceException,\n      min: minRecurrenceDate,\n      max: maxRecurrenceDate,\n      firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),\n      start: appointment.startDate,\n      end: appointment.endDate,\n      getPostProcessedException: function (date) {\n        var timeZoneName = _this5.scheduler.option(\"timeZone\");\n\n        if ((0, _type.isEmptyObject)(timeZoneName) || _utilsTimeZone.default.isEqualLocalTimeZone(timeZoneName, date)) {\n          return date;\n        }\n\n        var appointmentOffset = _this5.timeZoneCalculator.getOffsets(appointment.startDate).common;\n\n        var exceptionAppointmentOffset = _this5.timeZoneCalculator.getOffsets(date).common;\n\n        var diff = appointmentOffset - exceptionAppointmentOffset;\n        diff = _this5._getProcessedNotNativeDateIfCrossDST(date, diff);\n        return new Date(date.getTime() - diff * _date.default.dateToMilliseconds(\"hour\"));\n      }\n    };\n  };\n\n  _proto2._createRecurrenceAppointments = function (appointment, resources) {\n    var duration = appointment.duration;\n\n    var option = this._createRecurrenceOptions(appointment);\n\n    var generatedStartDates = (0, _recurrence.getRecurrenceProcessor)().generateDates(option);\n    return generatedStartDates.map(function (date) {\n      var utcDate = _utilsTimeZone.default.createUTCDateWithLocalOffset(date);\n\n      utcDate.setTime(utcDate.getTime() + duration);\n\n      var endDate = _utilsTimeZone.default.createDateFromUTCWithLocalOffset(utcDate);\n\n      return {\n        startDate: new Date(date),\n        endDate: endDate\n      };\n    });\n  };\n\n  _proto2._getGroupIndices = function (resources) {\n    var workspace = this.scheduler._workSpace;\n    return workspace._getGroupIndexes(resources);\n  };\n\n  _proto2._cropAppointmentsByStartDayHour = function (appointments, rawAppointment, isAllDay) {\n    var _this6 = this;\n\n    return appointments.map(function (appointment) {\n      var startDate = new Date(appointment.startDate);\n\n      var firstViewDate = _this6._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n      var startDayHour = _this6._getViewStartDayHour(firstViewDate);\n\n      appointment.startDate = _this6._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: startDate,\n        startDayHour: startDayHour,\n        firstViewDate: firstViewDate\n      });\n      return appointment;\n    });\n  };\n\n  _proto2._getAppointmentFirstViewDate = function () {\n    return this.scheduler.getStartViewDate();\n  };\n\n  _proto2._getViewStartDayHour = function () {\n    return this.scheduler._getCurrentViewOption(\"startDayHour\");\n  };\n\n  _proto2._getAppointmentResultDate = function (options) {\n    var appointment = options.appointment,\n        rawAppointment = options.rawAppointment,\n        startDayHour = options.startDayHour,\n        firstViewDate = options.firstViewDate;\n    var startDate = options.startDate;\n    var resultDate = new Date(appointment.startDate);\n\n    if (this.scheduler.appointmentTakesAllDay(rawAppointment)) {\n      resultDate = _date.default.normalizeDate(startDate, firstViewDate);\n    } else {\n      if (startDate < firstViewDate) {\n        startDate = firstViewDate;\n      }\n\n      resultDate = _date.default.normalizeDate(appointment.startDate, startDate);\n    }\n\n    return _date.default.roundDateByStartDayHour(resultDate, startDayHour);\n  };\n\n  _proto2._createAppointmentInfos = function (gridAppointments, resources, allDay, recurrent) {\n    var _this7 = this;\n\n    var result = [];\n\n    var _loop = function (i) {\n      var coordinates = _this7.scheduler._workSpace.getCoordinatesByDateInGroup(gridAppointments[i].startDate, resources, allDay);\n\n      coordinates.forEach(function (coordinate) {\n        (0, _extend.extend)(coordinate, {\n          info: {\n            appointment: gridAppointments[i],\n            sourceAppointment: gridAppointments[i].source\n          }\n        });\n      });\n      result = result.concat(coordinates);\n    };\n\n    for (var i = 0; i < gridAppointments.length; i++) {\n      _loop(i);\n    }\n\n    return result;\n  };\n\n  _createClass(AppointmentSettingsGeneratorBaseStrategy, [{\n    key: \"timeZoneCalculator\",\n    get: function () {\n      return this.scheduler.timeZoneCalculator;\n    }\n  }, {\n    key: \"workspace\",\n    get: function () {\n      return this.scheduler.getWorkSpace();\n    }\n  }, {\n    key: \"viewDataProvider\",\n    get: function () {\n      return this.workspace.viewDataProvider;\n    }\n  }]);\n\n  return AppointmentSettingsGeneratorBaseStrategy;\n}();\n\nexports.AppointmentSettingsGeneratorBaseStrategy = AppointmentSettingsGeneratorBaseStrategy;\n\nvar AppointmentSettingsGeneratorVirtualStrategy = function (_AppointmentSettingsG) {\n  _inheritsLoose(AppointmentSettingsGeneratorVirtualStrategy, _AppointmentSettingsG);\n\n  function AppointmentSettingsGeneratorVirtualStrategy() {\n    return _AppointmentSettingsG.apply(this, arguments) || this;\n  }\n\n  var _proto3 = AppointmentSettingsGeneratorVirtualStrategy.prototype;\n\n  _proto3._createAppointmentInfos = function (gridAppointments, resources, allDay, recurrent) {\n    var _this8 = this;\n\n    var appointments = allDay ? gridAppointments : gridAppointments.filter(function (item) {\n      var source = item.source,\n          startDate = item.startDate,\n          endDate = item.endDate;\n      var groupIndex = source.groupIndex;\n      return _this8.viewDataProvider.isGroupIntersectDateInterval(groupIndex, startDate, endDate);\n    });\n\n    if (recurrent && this.isVerticalGrouping) {\n      return this._createRecurrentAppointmentInfos(appointments, resources, allDay);\n    }\n\n    return _AppointmentSettingsG.prototype._createAppointmentInfos.call(this, appointments, resources, allDay, recurrent);\n  };\n\n  _proto3._createRecurrentAppointmentInfos = function (gridAppointments, resources, allDay) {\n    var _this9 = this;\n\n    var result = [];\n    gridAppointments.forEach(function (appointment) {\n      var source = appointment.source;\n      var groupIndex = source.groupIndex;\n\n      var coordinate = _this9.workspace.getCoordinatesByDate(appointment.startDate, groupIndex, allDay);\n\n      if (coordinate) {\n        (0, _extend.extend)(coordinate, {\n          info: {\n            appointment: appointment,\n            sourceAppointment: source\n          }\n        });\n        result.push(coordinate);\n      }\n    });\n    return result;\n  };\n\n  _proto3._cropAppointmentsByStartDayHour = function (appointments, rawAppointment, isAllDay) {\n    var _this10 = this;\n\n    return appointments.filter(function (appointment) {\n      var firstViewDate = _this10._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n      if (!firstViewDate) {\n        return false;\n      }\n\n      var startDayHour = _this10._getViewStartDayHour(firstViewDate);\n\n      var startDate = new Date(appointment.startDate);\n      appointment.startDate = _this10._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: startDate,\n        startDayHour: startDayHour,\n        firstViewDate: firstViewDate\n      });\n      return !isAllDay ? appointment.endDate > appointment.startDate : true;\n    });\n  };\n\n  _proto3._createRecurrenceAppointments = function (appointment, resources) {\n    var _this11 = this;\n\n    var duration = appointment.duration;\n    var result = [];\n    var groupIndices = this.isVerticalGrouping && this.workspace._getGroupCount() ? this._getGroupIndices(resources) : [0];\n    groupIndices.forEach(function (groupIndex) {\n      var option = _this11._createRecurrenceOptions(appointment, groupIndex);\n\n      var generatedStartDates = (0, _recurrence.getRecurrenceProcessor)().generateDates(option);\n      var recurrentInfo = generatedStartDates.map(function (date) {\n        var startDate = new Date(date);\n\n        var utcDate = _utilsTimeZone.default.createUTCDateWithLocalOffset(date);\n\n        utcDate.setTime(utcDate.getTime() + duration);\n\n        var endDate = _utilsTimeZone.default.createDateFromUTCWithLocalOffset(utcDate);\n\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          groupIndex: groupIndex\n        };\n      });\n      result.push.apply(result, _toConsumableArray(recurrentInfo));\n    });\n    return result;\n  };\n\n  _proto3._getViewStartDayHour = function (firstViewDate) {\n    return firstViewDate.getHours();\n  };\n\n  _proto3._getAppointmentFirstViewDate = function (appointment, rawAppointment) {\n    var _this$scheduler$getWo = this.scheduler.getWorkSpace(),\n        viewDataProvider = _this$scheduler$getWo.viewDataProvider;\n\n    var groupIndex = appointment.source.groupIndex;\n    var startDate = appointment.startDate,\n        endDate = appointment.endDate;\n\n    var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n    return viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay);\n  };\n\n  _proto3._updateGroupIndices = function (appointments, itemResources) {\n    var _this12 = this;\n\n    var groupIndices = this.isVerticalGrouping ? this._getGroupIndices(itemResources) : [0];\n    var result = [];\n    groupIndices.forEach(function (groupIndex) {\n      var groupStartDate = _this12.viewDataProvider.getGroupStartDate(groupIndex);\n\n      if (groupStartDate) {\n        appointments.forEach(function (appointment) {\n          var appointmentCopy = (0, _extend.extend)({}, appointment);\n          appointmentCopy.groupIndex = groupIndex;\n          result.push(appointmentCopy);\n        });\n      }\n    });\n    return result;\n  };\n\n  _proto3._getGroupIndices = function (resources) {\n    var groupIndices = _AppointmentSettingsG.prototype._getGroupIndices.call(this, resources);\n\n    var _this$scheduler$getWo2 = this.scheduler.getWorkSpace(),\n        viewDataProvider = _this$scheduler$getWo2.viewDataProvider;\n\n    var viewDataGroupIndices = viewDataProvider.getGroupIndices();\n    var result = groupIndices.filter(function (groupIndex) {\n      return viewDataGroupIndices.indexOf(groupIndex) !== -1;\n    });\n    return result;\n  };\n\n  _proto3._createAppointments = function (appointment, resources) {\n    var appointments = _AppointmentSettingsG.prototype._createAppointments.call(this, appointment, resources);\n\n    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, resources) : appointments;\n  };\n\n  _createClass(AppointmentSettingsGeneratorVirtualStrategy, [{\n    key: \"viewDataProvider\",\n    get: function () {\n      return this.workspace.viewDataProvider;\n    }\n  }, {\n    key: \"isVerticalGrouping\",\n    get: function () {\n      return this.workspace._isVerticalGroupedWorkSpace();\n    }\n  }]);\n\n  return AppointmentSettingsGeneratorVirtualStrategy;\n}(AppointmentSettingsGeneratorBaseStrategy);\n\nexports.AppointmentSettingsGeneratorVirtualStrategy = AppointmentSettingsGeneratorVirtualStrategy;","map":{"version":3,"sources":["/home/emma/node_modules/devextreme/ui/scheduler/appointmentSettingsGenerator.js"],"names":["exports","AppointmentSettingsGeneratorVirtualStrategy","AppointmentSettingsGeneratorBaseStrategy","AppointmentSettingsGenerator","_date","_interopRequireDefault","require","_type","_extend","_recurrence","_utilsTimeZone","obj","__esModule","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","minLen","n","toString","call","slice","name","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","return","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","configurable","writable","_defineProperties","props","descriptor","_createClass","Constructor","protoProps","staticProps","toMs","default","dateToMilliseconds","scheduler","settingsStrategy","isVirtualScrolling","_proto","rawAppointment","_proto2","appointment","createAppointmentAdapter","itemResources","_resourcesManager","getResourcesFromItem","isAllDay","_isAllDayAppointment","appointmentList","_createAppointments","_getProcessedByAppointmentTimeZone","_canProcessNotNativeTimezoneDates","_getProcessedNotNativeTimezoneDates","gridAppointmentList","_createGridAppointmentList","_cropAppointmentsByStartDayHour","_getProcessedLongAppointmentsIfRequired","appointmentInfos","_createAppointmentInfos","isRecurrent","_this","hasAppointmentTimeZone","isEmptyObject","startDateTimeZone","endDateTimeZone","appointmentOffsets","startDate","timeZoneCalculator","getOffsets","endDate","a","sourceOffsets","startDateOffsetDiff","endDateOffsetDiff","Date","getTime","appointmentTakesAllDay","workspace","supportAllDayRow","resources","appointments","_createRecurrenceAppointments","map","item","_item$endDate","resultEndTime","setTime","exceptionDate","timeZoneName","option","isTimeZoneSet","isEqualLocalTimeZone","_getProcessedNotNativeDateIfCrossDST","date","offset","newDate","newDateMinusOneHour","setHours","getHours","newDateOffset","common","newDateMinusOneHourOffset","_this2","startDateRange","endDateRange","startDateRangeOffset","endDateRangeOffset","isChangeOffsetInRange","diffStartDateOffset","diffEndDateOffset","newStartDate","newEndDate","testNewStartDate","createDate","path","testNewEndDate","duration","_this3","allDay","dateRange","getDateRange","renderingStrategy","getLayoutManager","getRenderingStrategyInstance","needSeparateAppointment","longStartDateParts","resultDates","gridAppointment","maxDate","endDateOfPart","normalizeEndDateByViewEnd","getDatesOfInterval","milliseconds","getWorkSpace","getIntervalDuration","list","startDatePart","setMilliseconds","concat","_this4","offsetDifference","getTimezoneOffset","_createExtremeRecurrenceDates","startViewDate","trimTime","endViewDate","commonTimeZone","daylightOffset","getDaylightOffsetInMs","_createRecurrenceOptions","groupIndex","_this5","_this$_createExtremeR","_this$_createExtremeR2","minRecurrenceDate","maxRecurrenceDate","rule","recurrenceRule","exception","recurrenceException","min","max","firstDayOfWeek","getFirstDayOfWeek","start","end","getPostProcessedException","appointmentOffset","exceptionAppointmentOffset","diff","generatedStartDates","getRecurrenceProcessor","generateDates","utcDate","createUTCDateWithLocalOffset","createDateFromUTCWithLocalOffset","_getGroupIndices","_workSpace","_getGroupIndexes","_this6","firstViewDate","_getAppointmentFirstViewDate","startDayHour","_getViewStartDayHour","_getAppointmentResultDate","getStartViewDate","_getCurrentViewOption","options","resultDate","normalizeDate","roundDateByStartDayHour","gridAppointments","recurrent","_this7","result","_loop","coordinates","getCoordinatesByDateInGroup","coordinate","extend","info","sourceAppointment","get","viewDataProvider","_AppointmentSettingsG","_proto3","_this8","isGroupIntersectDateInterval","isVerticalGrouping","_createRecurrentAppointmentInfos","_this9","getCoordinatesByDate","_this10","_this11","groupIndices","_getGroupCount","recurrentInfo","_this$scheduler$getWo","findGroupCellStartDate","_updateGroupIndices","_this12","groupStartDate","getGroupStartDate","appointmentCopy","_this$scheduler$getWo2","viewDataGroupIndices","getGroupIndices","indexOf","_isVerticalGroupedWorkSpace"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (ui/scheduler/appointmentSettingsGenerator.js)\r\n * Version: 20.2.7\r\n * Build date: Thu Apr 22 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nexports.AppointmentSettingsGeneratorVirtualStrategy = exports.AppointmentSettingsGeneratorBaseStrategy = exports.AppointmentSettingsGenerator = void 0;\r\nvar _date = _interopRequireDefault(require(\"../../core/utils/date\"));\r\nvar _type = require(\"../../core/utils/type\");\r\nvar _extend = require(\"../../core/utils/extend\");\r\nvar _recurrence = require(\"./recurrence\");\r\nvar _utilsTimeZone = _interopRequireDefault(require(\"./utils.timeZone.js\"));\r\n\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        \"default\": obj\r\n    }\r\n}\r\n\r\nfunction _toConsumableArray(arr) {\r\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()\r\n}\r\n\r\nfunction _nonIterableSpread() {\r\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\r\n}\r\n\r\nfunction _iterableToArray(iter) {\r\n    if (\"undefined\" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter[\"@@iterator\"]) {\r\n        return Array.from(iter)\r\n    }\r\n}\r\n\r\nfunction _arrayWithoutHoles(arr) {\r\n    if (Array.isArray(arr)) {\r\n        return _arrayLikeToArray(arr)\r\n    }\r\n}\r\n\r\nfunction _inheritsLoose(subClass, superClass) {\r\n    subClass.prototype = Object.create(superClass.prototype);\r\n    subClass.prototype.constructor = subClass;\r\n    _setPrototypeOf(subClass, superClass)\r\n}\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {\r\n        o.__proto__ = p;\r\n        return o\r\n    };\r\n    return _setPrototypeOf(o, p)\r\n}\r\n\r\nfunction _slicedToArray(arr, i) {\r\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest()\r\n}\r\n\r\nfunction _nonIterableRest() {\r\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\r\n}\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) {\r\n    if (!o) {\r\n        return\r\n    }\r\n    if (\"string\" === typeof o) {\r\n        return _arrayLikeToArray(o, minLen)\r\n    }\r\n    var n = Object.prototype.toString.call(o).slice(8, -1);\r\n    if (\"Object\" === n && o.constructor) {\r\n        n = o.constructor.name\r\n    }\r\n    if (\"Map\" === n || \"Set\" === n) {\r\n        return Array.from(o)\r\n    }\r\n    if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\r\n        return _arrayLikeToArray(o, minLen)\r\n    }\r\n}\r\n\r\nfunction _arrayLikeToArray(arr, len) {\r\n    if (null == len || len > arr.length) {\r\n        len = arr.length\r\n    }\r\n    for (var i = 0, arr2 = new Array(len); i < len; i++) {\r\n        arr2[i] = arr[i]\r\n    }\r\n    return arr2\r\n}\r\n\r\nfunction _iterableToArrayLimit(arr, i) {\r\n    var _i = arr && (\"undefined\" !== typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]);\r\n    if (null == _i) {\r\n        return\r\n    }\r\n    var _arr = [];\r\n    var _n = true;\r\n    var _d = false;\r\n    var _s, _e;\r\n    try {\r\n        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\r\n            _arr.push(_s.value);\r\n            if (i && _arr.length === i) {\r\n                break\r\n            }\r\n        }\r\n    } catch (err) {\r\n        _d = true;\r\n        _e = err\r\n    } finally {\r\n        try {\r\n            if (!_n && null != _i.return) {\r\n                _i.return()\r\n            }\r\n        } finally {\r\n            if (_d) {\r\n                throw _e\r\n            }\r\n        }\r\n    }\r\n    return _arr\r\n}\r\n\r\nfunction _arrayWithHoles(arr) {\r\n    if (Array.isArray(arr)) {\r\n        return arr\r\n    }\r\n}\r\n\r\nfunction ownKeys(object, enumerableOnly) {\r\n    var keys = Object.keys(object);\r\n    if (Object.getOwnPropertySymbols) {\r\n        var symbols = Object.getOwnPropertySymbols(object);\r\n        if (enumerableOnly) {\r\n            symbols = symbols.filter(function(sym) {\r\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable\r\n            })\r\n        }\r\n        keys.push.apply(keys, symbols)\r\n    }\r\n    return keys\r\n}\r\n\r\nfunction _objectSpread(target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n        var source = null != arguments[i] ? arguments[i] : {};\r\n        if (i % 2) {\r\n            ownKeys(Object(source), true).forEach(function(key) {\r\n                _defineProperty(target, key, source[key])\r\n            })\r\n        } else {\r\n            if (Object.getOwnPropertyDescriptors) {\r\n                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))\r\n            } else {\r\n                ownKeys(Object(source)).forEach(function(key) {\r\n                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key))\r\n                })\r\n            }\r\n        }\r\n    }\r\n    return target\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n    if (key in obj) {\r\n        Object.defineProperty(obj, key, {\r\n            value: value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true\r\n        })\r\n    } else {\r\n        obj[key] = value\r\n    }\r\n    return obj\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n    for (var i = 0; i < props.length; i++) {\r\n        var descriptor = props[i];\r\n        descriptor.enumerable = descriptor.enumerable || false;\r\n        descriptor.configurable = true;\r\n        if (\"value\" in descriptor) {\r\n            descriptor.writable = true\r\n        }\r\n        Object.defineProperty(target, descriptor.key, descriptor)\r\n    }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n    if (protoProps) {\r\n        _defineProperties(Constructor.prototype, protoProps)\r\n    }\r\n    if (staticProps) {\r\n        _defineProperties(Constructor, staticProps)\r\n    }\r\n    return Constructor\r\n}\r\nvar toMs = _date.default.dateToMilliseconds;\r\nvar AppointmentSettingsGenerator = function() {\r\n    function AppointmentSettingsGenerator(scheduler) {\r\n        this.scheduler = scheduler;\r\n        this.settingsStrategy = this.scheduler.isVirtualScrolling() ? new AppointmentSettingsGeneratorVirtualStrategy(this.scheduler) : new AppointmentSettingsGeneratorBaseStrategy(this.scheduler)\r\n    }\r\n    var _proto = AppointmentSettingsGenerator.prototype;\r\n    _proto.create = function(rawAppointment) {\r\n        return this.settingsStrategy.create(rawAppointment)\r\n    };\r\n    return AppointmentSettingsGenerator\r\n}();\r\nexports.AppointmentSettingsGenerator = AppointmentSettingsGenerator;\r\nvar AppointmentSettingsGeneratorBaseStrategy = function() {\r\n    function AppointmentSettingsGeneratorBaseStrategy(scheduler) {\r\n        this.scheduler = scheduler\r\n    }\r\n    var _proto2 = AppointmentSettingsGeneratorBaseStrategy.prototype;\r\n    _proto2.create = function(rawAppointment) {\r\n        var scheduler = this.scheduler;\r\n        var appointment = scheduler.createAppointmentAdapter(rawAppointment);\r\n        var itemResources = scheduler._resourcesManager.getResourcesFromItem(rawAppointment);\r\n        var isAllDay = this._isAllDayAppointment(rawAppointment);\r\n        var appointmentList = this._createAppointments(appointment, itemResources);\r\n        appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointment);\r\n        if (this._canProcessNotNativeTimezoneDates(appointment)) {\r\n            appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointment)\r\n        }\r\n        var gridAppointmentList = this._createGridAppointmentList(appointmentList, appointment);\r\n        gridAppointmentList = this._cropAppointmentsByStartDayHour(gridAppointmentList, rawAppointment, isAllDay);\r\n        gridAppointmentList = this._getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment);\r\n        var appointmentInfos = this._createAppointmentInfos(gridAppointmentList, itemResources, isAllDay, appointment.isRecurrent);\r\n        return appointmentInfos\r\n    };\r\n    _proto2._getProcessedByAppointmentTimeZone = function(appointmentList, appointment) {\r\n        var _this = this;\r\n        var hasAppointmentTimeZone = !(0, _type.isEmptyObject)(appointment.startDateTimeZone) || !(0, _type.isEmptyObject)(appointment.endDateTimeZone);\r\n        if (appointmentList.length > 1 && hasAppointmentTimeZone) {\r\n            var appointmentOffsets = {\r\n                startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\r\n                endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\r\n            };\r\n            appointmentList.forEach(function(a) {\r\n                var sourceOffsets = {\r\n                    startDate: _this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\r\n                    endDate: _this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone)\r\n                };\r\n                var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets.startDate.appointment;\r\n                var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets.endDate.appointment;\r\n                if (0 !== startDateOffsetDiff) {\r\n                    a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n                if (0 !== endDateOffsetDiff) {\r\n                    a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n            })\r\n        }\r\n        return appointmentList\r\n    };\r\n    _proto2._isAllDayAppointment = function(rawAppointment) {\r\n        return this.scheduler.appointmentTakesAllDay(rawAppointment) && this.workspace.supportAllDayRow()\r\n    };\r\n    _proto2._createAppointments = function(appointment, resources) {\r\n        var appointments = this._createRecurrenceAppointments(appointment, resources);\r\n        if (!appointment.isRecurrent && 0 === appointments.length) {\r\n            appointments.push({\r\n                startDate: appointment.startDate,\r\n                endDate: appointment.endDate\r\n            })\r\n        }\r\n        appointments = appointments.map(function(item) {\r\n            var _item$endDate;\r\n            var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\r\n            if (item.startDate.getTime() === resultEndTime) {\r\n                item.endDate.setTime(resultEndTime + toMs(\"minute\"))\r\n            }\r\n            return _objectSpread(_objectSpread({}, item), {}, {\r\n                exceptionDate: new Date(item.startDate)\r\n            })\r\n        });\r\n        return appointments\r\n    };\r\n    _proto2._canProcessNotNativeTimezoneDates = function(appointment) {\r\n        var timeZoneName = this.scheduler.option(\"timeZone\");\r\n        var isTimeZoneSet = !(0, _type.isEmptyObject)(timeZoneName);\r\n        if (!isTimeZoneSet) {\r\n            return false\r\n        }\r\n        if (!appointment.isRecurrent) {\r\n            return false\r\n        }\r\n        return !_utilsTimeZone.default.isEqualLocalTimeZone(timeZoneName, appointment.startDate)\r\n    };\r\n    _proto2._getProcessedNotNativeDateIfCrossDST = function(date, offset) {\r\n        if (offset < 0) {\r\n            var newDate = new Date(date);\r\n            var newDateMinusOneHour = new Date(newDate);\r\n            newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\r\n            var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\r\n            var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\r\n            if (newDateOffset !== newDateMinusOneHourOffset) {\r\n                return 0\r\n            }\r\n        }\r\n        return offset\r\n    };\r\n    _proto2._getProcessedNotNativeTimezoneDates = function(appointmentList, appointment) {\r\n        var _this2 = this;\r\n        var startDateRange = appointment.startDate;\r\n        var endDateRange = appointmentList[appointmentList.length - 1].endDate;\r\n        var startDateRangeOffset = this.timeZoneCalculator.getOffsets(startDateRange).common;\r\n        var endDateRangeOffset = this.timeZoneCalculator.getOffsets(endDateRange).common;\r\n        var isChangeOffsetInRange = startDateRangeOffset !== endDateRangeOffset;\r\n        if (isChangeOffsetInRange) {\r\n            return appointmentList.map(function(a) {\r\n                var diffStartDateOffset = _this2.timeZoneCalculator.getOffsets(appointment.startDate).common - _this2.timeZoneCalculator.getOffsets(a.startDate).common;\r\n                var diffEndDateOffset = _this2.timeZoneCalculator.getOffsets(appointment.endDate).common - _this2.timeZoneCalculator.getOffsets(a.endDate).common;\r\n                diffStartDateOffset = _this2._getProcessedNotNativeDateIfCrossDST(a.startDate, diffStartDateOffset);\r\n                diffEndDateOffset = _this2._getProcessedNotNativeDateIfCrossDST(a.endDate, diffEndDateOffset);\r\n                var newStartDate = new Date(a.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\r\n                var newEndDate = new Date(a.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\r\n                var testNewStartDate = _this2.timeZoneCalculator.createDate(newStartDate, {\r\n                    path: \"toGrid\"\r\n                });\r\n                var testNewEndDate = _this2.timeZoneCalculator.createDate(newEndDate, {\r\n                    path: \"toGrid\"\r\n                });\r\n                if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\r\n                    newEndDate = new Date(newStartDate.getTime() + appointment.duration)\r\n                }\r\n                return {\r\n                    startDate: newStartDate,\r\n                    endDate: newEndDate,\r\n                    exceptionDate: new Date(newStartDate)\r\n                }\r\n            })\r\n        }\r\n        return appointmentList\r\n    };\r\n    _proto2._getProcessedLongAppointmentsIfRequired = function(gridAppointmentList, appointment) {\r\n        var _this3 = this;\r\n        var rawAppointment = appointment.source();\r\n        var allDay = this.scheduler.appointmentTakesAllDay(rawAppointment);\r\n        var dateRange = this.workspace.getDateRange();\r\n        var renderingStrategy = this.scheduler.getLayoutManager().getRenderingStrategyInstance();\r\n        if (renderingStrategy.needSeparateAppointment(allDay)) {\r\n            var longStartDateParts = [];\r\n            var resultDates = [];\r\n            gridAppointmentList.forEach(function(gridAppointment) {\r\n                var maxDate = new Date(dateRange[1]);\r\n                var endDateOfPart = renderingStrategy.normalizeEndDateByViewEnd(rawAppointment, gridAppointment.endDate);\r\n                longStartDateParts = _date.default.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\r\n                    milliseconds: _this3.scheduler.getWorkSpace().getIntervalDuration(allDay)\r\n                });\r\n                var list = longStartDateParts.filter(function(startDatePart) {\r\n                    return new Date(startDatePart) < maxDate\r\n                }).map(function(date) {\r\n                    return {\r\n                        startDate: date,\r\n                        endDate: new Date(new Date(date).setMilliseconds(appointment.duration)),\r\n                        source: gridAppointment.source\r\n                    }\r\n                });\r\n                resultDates = resultDates.concat(list)\r\n            });\r\n            gridAppointmentList = resultDates\r\n        }\r\n        return gridAppointmentList\r\n    };\r\n    _proto2._createGridAppointmentList = function(appointmentList, appointment) {\r\n        var _this4 = this;\r\n        return appointmentList.map(function(source) {\r\n            var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\r\n            if (0 !== offsetDifference && _this4._canProcessNotNativeTimezoneDates(appointment)) {\r\n                source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.exceptionDate = new Date(source.startDate)\r\n            }\r\n            var startDate = _this4.timeZoneCalculator.createDate(source.startDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var endDate = _this4.timeZoneCalculator.createDate(source.endDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            return {\r\n                startDate: startDate,\r\n                endDate: endDate,\r\n                source: source\r\n            }\r\n        })\r\n    };\r\n    _proto2._createExtremeRecurrenceDates = function(rawAppointment) {\r\n        var dateRange = this.workspace.getDateRange();\r\n        var startViewDate = this.scheduler.appointmentTakesAllDay(rawAppointment) ? _date.default.trimTime(dateRange[0]) : dateRange[0];\r\n        var endViewDate = dateRange[1];\r\n        var commonTimeZone = this.scheduler.option(\"timeZone\");\r\n        if (commonTimeZone) {\r\n            startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            endViewDate = this.timeZoneCalculator.createDate(endViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            var daylightOffset = _utilsTimeZone.default.getDaylightOffsetInMs(startViewDate, endViewDate);\r\n            if (daylightOffset) {\r\n                endViewDate = new Date(endViewDate.getTime() + daylightOffset)\r\n            }\r\n        }\r\n        return [startViewDate, endViewDate]\r\n    };\r\n    _proto2._createRecurrenceOptions = function(appointment, groupIndex) {\r\n        var _this5 = this;\r\n        var _this$_createExtremeR = this._createExtremeRecurrenceDates(appointment.source(), groupIndex),\r\n            _this$_createExtremeR2 = _slicedToArray(_this$_createExtremeR, 2),\r\n            minRecurrenceDate = _this$_createExtremeR2[0],\r\n            maxRecurrenceDate = _this$_createExtremeR2[1];\r\n        return {\r\n            rule: appointment.recurrenceRule,\r\n            exception: appointment.recurrenceException,\r\n            min: minRecurrenceDate,\r\n            max: maxRecurrenceDate,\r\n            firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),\r\n            start: appointment.startDate,\r\n            end: appointment.endDate,\r\n            getPostProcessedException: function(date) {\r\n                var timeZoneName = _this5.scheduler.option(\"timeZone\");\r\n                if ((0, _type.isEmptyObject)(timeZoneName) || _utilsTimeZone.default.isEqualLocalTimeZone(timeZoneName, date)) {\r\n                    return date\r\n                }\r\n                var appointmentOffset = _this5.timeZoneCalculator.getOffsets(appointment.startDate).common;\r\n                var exceptionAppointmentOffset = _this5.timeZoneCalculator.getOffsets(date).common;\r\n                var diff = appointmentOffset - exceptionAppointmentOffset;\r\n                diff = _this5._getProcessedNotNativeDateIfCrossDST(date, diff);\r\n                return new Date(date.getTime() - diff * _date.default.dateToMilliseconds(\"hour\"))\r\n            }\r\n        }\r\n    };\r\n    _proto2._createRecurrenceAppointments = function(appointment, resources) {\r\n        var duration = appointment.duration;\r\n        var option = this._createRecurrenceOptions(appointment);\r\n        var generatedStartDates = (0, _recurrence.getRecurrenceProcessor)().generateDates(option);\r\n        return generatedStartDates.map(function(date) {\r\n            var utcDate = _utilsTimeZone.default.createUTCDateWithLocalOffset(date);\r\n            utcDate.setTime(utcDate.getTime() + duration);\r\n            var endDate = _utilsTimeZone.default.createDateFromUTCWithLocalOffset(utcDate);\r\n            return {\r\n                startDate: new Date(date),\r\n                endDate: endDate\r\n            }\r\n        })\r\n    };\r\n    _proto2._getGroupIndices = function(resources) {\r\n        var workspace = this.scheduler._workSpace;\r\n        return workspace._getGroupIndexes(resources)\r\n    };\r\n    _proto2._cropAppointmentsByStartDayHour = function(appointments, rawAppointment, isAllDay) {\r\n        var _this6 = this;\r\n        return appointments.map(function(appointment) {\r\n            var startDate = new Date(appointment.startDate);\r\n            var firstViewDate = _this6._getAppointmentFirstViewDate(appointment, rawAppointment);\r\n            var startDayHour = _this6._getViewStartDayHour(firstViewDate);\r\n            appointment.startDate = _this6._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: startDate,\r\n                startDayHour: startDayHour,\r\n                firstViewDate: firstViewDate\r\n            });\r\n            return appointment\r\n        })\r\n    };\r\n    _proto2._getAppointmentFirstViewDate = function() {\r\n        return this.scheduler.getStartViewDate()\r\n    };\r\n    _proto2._getViewStartDayHour = function() {\r\n        return this.scheduler._getCurrentViewOption(\"startDayHour\")\r\n    };\r\n    _proto2._getAppointmentResultDate = function(options) {\r\n        var appointment = options.appointment,\r\n            rawAppointment = options.rawAppointment,\r\n            startDayHour = options.startDayHour,\r\n            firstViewDate = options.firstViewDate;\r\n        var startDate = options.startDate;\r\n        var resultDate = new Date(appointment.startDate);\r\n        if (this.scheduler.appointmentTakesAllDay(rawAppointment)) {\r\n            resultDate = _date.default.normalizeDate(startDate, firstViewDate)\r\n        } else {\r\n            if (startDate < firstViewDate) {\r\n                startDate = firstViewDate\r\n            }\r\n            resultDate = _date.default.normalizeDate(appointment.startDate, startDate)\r\n        }\r\n        return _date.default.roundDateByStartDayHour(resultDate, startDayHour)\r\n    };\r\n    _proto2._createAppointmentInfos = function(gridAppointments, resources, allDay, recurrent) {\r\n        var _this7 = this;\r\n        var result = [];\r\n        var _loop = function(i) {\r\n            var coordinates = _this7.scheduler._workSpace.getCoordinatesByDateInGroup(gridAppointments[i].startDate, resources, allDay);\r\n            coordinates.forEach(function(coordinate) {\r\n                (0, _extend.extend)(coordinate, {\r\n                    info: {\r\n                        appointment: gridAppointments[i],\r\n                        sourceAppointment: gridAppointments[i].source\r\n                    }\r\n                })\r\n            });\r\n            result = result.concat(coordinates)\r\n        };\r\n        for (var i = 0; i < gridAppointments.length; i++) {\r\n            _loop(i)\r\n        }\r\n        return result\r\n    };\r\n    _createClass(AppointmentSettingsGeneratorBaseStrategy, [{\r\n        key: \"timeZoneCalculator\",\r\n        get: function() {\r\n            return this.scheduler.timeZoneCalculator\r\n        }\r\n    }, {\r\n        key: \"workspace\",\r\n        get: function() {\r\n            return this.scheduler.getWorkSpace()\r\n        }\r\n    }, {\r\n        key: \"viewDataProvider\",\r\n        get: function() {\r\n            return this.workspace.viewDataProvider\r\n        }\r\n    }]);\r\n    return AppointmentSettingsGeneratorBaseStrategy\r\n}();\r\nexports.AppointmentSettingsGeneratorBaseStrategy = AppointmentSettingsGeneratorBaseStrategy;\r\nvar AppointmentSettingsGeneratorVirtualStrategy = function(_AppointmentSettingsG) {\r\n    _inheritsLoose(AppointmentSettingsGeneratorVirtualStrategy, _AppointmentSettingsG);\r\n\r\n    function AppointmentSettingsGeneratorVirtualStrategy() {\r\n        return _AppointmentSettingsG.apply(this, arguments) || this\r\n    }\r\n    var _proto3 = AppointmentSettingsGeneratorVirtualStrategy.prototype;\r\n    _proto3._createAppointmentInfos = function(gridAppointments, resources, allDay, recurrent) {\r\n        var _this8 = this;\r\n        var appointments = allDay ? gridAppointments : gridAppointments.filter(function(item) {\r\n            var source = item.source,\r\n                startDate = item.startDate,\r\n                endDate = item.endDate;\r\n            var groupIndex = source.groupIndex;\r\n            return _this8.viewDataProvider.isGroupIntersectDateInterval(groupIndex, startDate, endDate)\r\n        });\r\n        if (recurrent && this.isVerticalGrouping) {\r\n            return this._createRecurrentAppointmentInfos(appointments, resources, allDay)\r\n        }\r\n        return _AppointmentSettingsG.prototype._createAppointmentInfos.call(this, appointments, resources, allDay, recurrent)\r\n    };\r\n    _proto3._createRecurrentAppointmentInfos = function(gridAppointments, resources, allDay) {\r\n        var _this9 = this;\r\n        var result = [];\r\n        gridAppointments.forEach(function(appointment) {\r\n            var source = appointment.source;\r\n            var groupIndex = source.groupIndex;\r\n            var coordinate = _this9.workspace.getCoordinatesByDate(appointment.startDate, groupIndex, allDay);\r\n            if (coordinate) {\r\n                (0, _extend.extend)(coordinate, {\r\n                    info: {\r\n                        appointment: appointment,\r\n                        sourceAppointment: source\r\n                    }\r\n                });\r\n                result.push(coordinate)\r\n            }\r\n        });\r\n        return result\r\n    };\r\n    _proto3._cropAppointmentsByStartDayHour = function(appointments, rawAppointment, isAllDay) {\r\n        var _this10 = this;\r\n        return appointments.filter(function(appointment) {\r\n            var firstViewDate = _this10._getAppointmentFirstViewDate(appointment, rawAppointment);\r\n            if (!firstViewDate) {\r\n                return false\r\n            }\r\n            var startDayHour = _this10._getViewStartDayHour(firstViewDate);\r\n            var startDate = new Date(appointment.startDate);\r\n            appointment.startDate = _this10._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: startDate,\r\n                startDayHour: startDayHour,\r\n                firstViewDate: firstViewDate\r\n            });\r\n            return !isAllDay ? appointment.endDate > appointment.startDate : true\r\n        })\r\n    };\r\n    _proto3._createRecurrenceAppointments = function(appointment, resources) {\r\n        var _this11 = this;\r\n        var duration = appointment.duration;\r\n        var result = [];\r\n        var groupIndices = this.isVerticalGrouping && this.workspace._getGroupCount() ? this._getGroupIndices(resources) : [0];\r\n        groupIndices.forEach(function(groupIndex) {\r\n            var option = _this11._createRecurrenceOptions(appointment, groupIndex);\r\n            var generatedStartDates = (0, _recurrence.getRecurrenceProcessor)().generateDates(option);\r\n            var recurrentInfo = generatedStartDates.map(function(date) {\r\n                var startDate = new Date(date);\r\n                var utcDate = _utilsTimeZone.default.createUTCDateWithLocalOffset(date);\r\n                utcDate.setTime(utcDate.getTime() + duration);\r\n                var endDate = _utilsTimeZone.default.createDateFromUTCWithLocalOffset(utcDate);\r\n                return {\r\n                    startDate: startDate,\r\n                    endDate: endDate,\r\n                    groupIndex: groupIndex\r\n                }\r\n            });\r\n            result.push.apply(result, _toConsumableArray(recurrentInfo))\r\n        });\r\n        return result\r\n    };\r\n    _proto3._getViewStartDayHour = function(firstViewDate) {\r\n        return firstViewDate.getHours()\r\n    };\r\n    _proto3._getAppointmentFirstViewDate = function(appointment, rawAppointment) {\r\n        var _this$scheduler$getWo = this.scheduler.getWorkSpace(),\r\n            viewDataProvider = _this$scheduler$getWo.viewDataProvider;\r\n        var groupIndex = appointment.source.groupIndex;\r\n        var startDate = appointment.startDate,\r\n            endDate = appointment.endDate;\r\n        var isAllDay = this._isAllDayAppointment(rawAppointment);\r\n        return viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay)\r\n    };\r\n    _proto3._updateGroupIndices = function(appointments, itemResources) {\r\n        var _this12 = this;\r\n        var groupIndices = this.isVerticalGrouping ? this._getGroupIndices(itemResources) : [0];\r\n        var result = [];\r\n        groupIndices.forEach(function(groupIndex) {\r\n            var groupStartDate = _this12.viewDataProvider.getGroupStartDate(groupIndex);\r\n            if (groupStartDate) {\r\n                appointments.forEach(function(appointment) {\r\n                    var appointmentCopy = (0, _extend.extend)({}, appointment);\r\n                    appointmentCopy.groupIndex = groupIndex;\r\n                    result.push(appointmentCopy)\r\n                })\r\n            }\r\n        });\r\n        return result\r\n    };\r\n    _proto3._getGroupIndices = function(resources) {\r\n        var groupIndices = _AppointmentSettingsG.prototype._getGroupIndices.call(this, resources);\r\n        var _this$scheduler$getWo2 = this.scheduler.getWorkSpace(),\r\n            viewDataProvider = _this$scheduler$getWo2.viewDataProvider;\r\n        var viewDataGroupIndices = viewDataProvider.getGroupIndices();\r\n        var result = groupIndices.filter(function(groupIndex) {\r\n            return viewDataGroupIndices.indexOf(groupIndex) !== -1\r\n        });\r\n        return result\r\n    };\r\n    _proto3._createAppointments = function(appointment, resources) {\r\n        var appointments = _AppointmentSettingsG.prototype._createAppointments.call(this, appointment, resources);\r\n        return !appointment.isRecurrent ? this._updateGroupIndices(appointments, resources) : appointments\r\n    };\r\n    _createClass(AppointmentSettingsGeneratorVirtualStrategy, [{\r\n        key: \"viewDataProvider\",\r\n        get: function() {\r\n            return this.workspace.viewDataProvider\r\n        }\r\n    }, {\r\n        key: \"isVerticalGrouping\",\r\n        get: function() {\r\n            return this.workspace._isVerticalGroupedWorkSpace()\r\n        }\r\n    }]);\r\n    return AppointmentSettingsGeneratorVirtualStrategy\r\n}(AppointmentSettingsGeneratorBaseStrategy);\r\nexports.AppointmentSettingsGeneratorVirtualStrategy = AppointmentSettingsGeneratorVirtualStrategy;\r\n"]},"metadata":{},"sourceType":"script"}